<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Django REST framework JWT</title>
  

  <link rel="shortcut icon" href="./img/favicon.ico">

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="./css/theme.css" type="text/css" />
  <link rel="stylesheet" href="./css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="./css/highlight.css">

  
  <script>
    // Current page data
    var mkdocs_page_name = "index"
  </script>
  
  <script src="./js/jquery-2.1.1.min.js"></script>
  <script src="./js/modernizr-2.8.3.min.js"></script>
  <script type="text/javascript" src="./js/highlight.pack.js"></script>
  <script src="./js/theme.js"></script> 

  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href="." class="icon icon-home"> Django REST framework JWT</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="./search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        <ul class="current">
          
            <li>
    <li class="toctree-l1 current">
        <a class="current" href=".">Home</a>
        
            <ul>
            
                <li class="toctree-l3"><a href="#rest-framework-jwt-auth">REST framework JWT Auth</a></li>
                
                    <li><a class="toctree-l4" href="#overview">Overview</a></li>
                
                    <li><a class="toctree-l4" href="#requirements">Requirements</a></li>
                
                    <li><a class="toctree-l4" href="#security">Security</a></li>
                
                    <li><a class="toctree-l4" href="#installation">Installation</a></li>
                
                    <li><a class="toctree-l4" href="#usage">Usage</a></li>
                
                    <li><a class="toctree-l4" href="#refresh-token">Refresh Token</a></li>
                
                    <li><a class="toctree-l4" href="#verify-token">Verify Token</a></li>
                
                    <li><a class="toctree-l4" href="#impersonation-token">Impersonation Token</a></li>
                
                    <li><a class="toctree-l4" href="#blacklisting-tokens">Blacklisting Tokens</a></li>
                
                    <li><a class="toctree-l4" href="#additional-settings">Additional Settings</a></li>
                
                    <li><a class="toctree-l4" href="#extendingoverriding-jsonwebtokenauthentication">Extending/Overriding JSONWebTokenAuthentication</a></li>
                
                    <li><a class="toctree-l4" href="#creating-a-new-token-manually">Creating a new token manually</a></li>
                
                    <li><a class="toctree-l4" href="#creating-a-new-token-on-the-command-line">Creating a new token on the command line</a></li>
                
            
            </ul>
        
    </li>
<li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href=".">Django REST framework JWT</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".">Docs</a> &raquo;</li>
    
      
    
    <li>Home</li>
    <li class="wy-breadcrumbs-aside">
      
        
          <a href="https://github.com/Styria-Digital/django-rest-framework-jwt" class="icon icon-github"> Edit on GitHub</a>
        
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="rest-framework-jwt-auth">REST framework JWT Auth</h1>
<p>JSON Web Token Authentication support for Django REST Framework</p>
<h2 id="overview">Overview</h2>
<p>This package provides <a href="http://tools.ietf.org/html/draft-ietf-oauth-json-web-token">JSON Web Token Authentication</a> support for <a href="http://django-rest-framework.org/">Django REST framework</a>.</p>
<p>If you want to know more about JWT, check out the following resources:</p>
<ul>
<li>DjangoCon 2014 - JSON Web Tokens <a href="https://www.youtube.com/watch?v=825hodQ61bg">Video</a> | <a href="https://speakerdeck.com/jpadilla/djangocon-json-web-tokens">Slides</a></li>
<li><a href="http://jpadilla.com/post/73791304724/auth-with-json-web-tokens">Auth with JSON Web Tokens</a></li>
<li><a href="http://jwt.io/">JWT.io</a></li>
</ul>
<h2 id="requirements">Requirements</h2>
<ul>
<li>Python 2.7, 3.4+</li>
<li>Django 1.11+</li>
<li>Django REST Framework 3.7+</li>
</ul>
<h2 id="security">Security</h2>
<p>Unlike some more typical uses of JWTs, this module only generates
authentication tokens that will verify the user who is requesting one of your DRF
protected API resources. The actual
request parameters themselves are <em>not</em> included in the JWT claims which means
they are not signed and may be tampered with. You should only expose your API
endpoints over SSL/TLS to protect against content tampering and certain kinds of
replay attacks.</p>
<h2 id="installation">Installation</h2>
<p>Install using <code>pip</code>...</p>
<pre><code class="language-bash">$ pip install drf-jwt
</code></pre>
<p>Add the app to your project:</p>
<pre><code class="language-bash">INSTALLED_APPS = [
    ...
    'rest_framework_jwt',
    'rest_framework_jwt.blacklist',
    ...
]
</code></pre>
<p>Note the <em>blacklist</em> app in <code>INSTALLED_APPS</code>. You have to add it even if you dont't use
 the feature to avoid DB issues.</p>
<h2 id="usage">Usage</h2>
<p>In your <code>settings.py</code>, add <code>JSONWebTokenAuthentication</code> to Django REST framework's <code>DEFAULT_AUTHENTICATION_CLASSES</code>.</p>
<pre><code class="language-python">REST_FRAMEWORK = {
    'DEFAULT_PERMISSION_CLASSES': (
        'rest_framework.permissions.IsAuthenticated',
    ),
    'DEFAULT_AUTHENTICATION_CLASSES': (
        'rest_framework_jwt.authentication.JSONWebTokenAuthentication',
        'rest_framework.authentication.SessionAuthentication',
        'rest_framework.authentication.BasicAuthentication',
    ),
}
</code></pre>
<p>In your <code>urls.py</code> add the following URL route to enable obtaining a token via a POST included the user's username and password.</p>
<pre><code class="language-python">from rest_framework_jwt.views import obtain_jwt_token
#...

urlpatterns = [
    '',
    # ...

    url(r'^api-token-auth/', obtain_jwt_token),
]
</code></pre>
<p>You can easily test if the endpoint is working by doing the following in your terminal, if you had a user created with the username <strong>admin</strong> and password <strong>password123</strong>.</p>
<pre><code class="language-bash">$ curl -X POST -d &quot;username=admin&amp;password=password123&quot; http://localhost:8000/api-token-auth/
</code></pre>
<p>Alternatively, you can use all the content types supported by the Django REST framework to obtain the auth token. For example:</p>
<pre><code class="language-bash">$ curl -X POST -H &quot;Content-Type: application/json&quot; -d '{&quot;username&quot;:&quot;admin&quot;,&quot;password&quot;:&quot;password123&quot;}' http://localhost:8000/api-token-auth/
</code></pre>
<p>Now in order to access protected api urls you must include the <code>Authorization: Bearer &lt;your_token&gt;</code> header.</p>
<pre><code class="language-bash">$ curl -H &quot;Authorization: Bearer &lt;your_token&gt;&quot; http://localhost:8000/protected-url/
</code></pre>
<p>In addition to adding the Authorization: Bearer in your requests, make sure that you have decorated your views properly. For this, import the <code>JSONWebTokenAuthentication</code> authentication class from <code>rest_framework_jwt.authentication</code></p>
<pre><code class="language-python">from rest_framework_jwt.authentication import JSONWebTokenAuthentication
</code></pre>
<p>If you are using django's function based views, then you should decorate your views with the authentication_classes decorator containing JSONWebTokenAuthentication as follows:</p>
<pre><code class="language-python">...
@authentication_classes([JSONWebTokenAuthentication])
def protectedView(request):
    ...
</code></pre>
<p>In case you are using class based views, you should override the <code>authentication_classes</code> attribute in the view like so:</p>
<pre><code class="language-python">class ExampleView(APIView):
    ...
    authentication_classes = [JSONWebTokenAuthentication]
    ...
</code></pre>
<p>This is necessary if the <code>JSONWebTokenAuthentication</code> class wasn't added to the <code>DEFAULT_AUTHENTICATION_CLASSES</code>, or if JWT authentication is needed <em>only</em> on certain views. If you have added it to <code>DEFAULT_AUTHENTICATION_CLASSES</code>, then the views will be authenticated using JWT authentication automatically.</p>
<h2 id="refresh-token">Refresh Token</h2>
<p>If <code>JWT_ALLOW_REFRESH</code> is True, <strong>non-expired</strong> tokens can be "refreshed" to obtain a brand new token with renewed expiration time. Add a URL pattern like this:</p>
<pre><code class="language-python">    from rest_framework_jwt.views import refresh_jwt_token
    #  ...

    urlpatterns = [
        #  ...
        url(r'^api-token-refresh/', refresh_jwt_token),
    ]
</code></pre>
<p>Pass in an existing token to the refresh endpoint as follows: <code>{"token": EXISTING_TOKEN}</code>. Note that only non-expired tokens will work. The JSON response looks the same as the normal obtain token endpoint <code>{"token": NEW_TOKEN}</code>.</p>
<pre><code class="language-bash">$ curl -X POST -H &quot;Content-Type: application/json&quot; -d '{&quot;token&quot;:&quot;&lt;EXISTING_TOKEN&gt;&quot;}' http://localhost:8000/api-token-refresh/
</code></pre>
<p>Refresh with tokens can be repeated (token1 -&gt; token2 -&gt; token3), but this chain of token stores the time that the original token (obtained with username/password credentials), as <code>orig_iat</code>. You can only keep refreshing tokens up to <code>JWT_REFRESH_EXPIRATION_DELTA</code>.</p>
<p>A typical use case might be a web app where you'd like to keep the user "logged in" the site without having to re-enter their password, or get kicked out by surprise before their token expired. Imagine they had a 1-hour token and are just at the last minute while they're still doing something. With mobile you could perhaps store the username/password to get a new token, but this is not a great idea in a browser. Each time the user loads the page, you can check if there is an existing non-expired token and if it's close to being expired, refresh it to extend their session. In other words, if a user is actively using your site, they can keep their "session" alive.</p>
<h2 id="verify-token">Verify Token</h2>
<p>In some microservice architectures, authentication is handled by a single service. Other services delegate the responsibility of confirming that a user is logged in to this authentication service. This usually means that a service will pass a JWT received from the user to the authentication service, and wait for a confirmation that the JWT is valid before returning protected resources to the user.</p>
<p>This setup is supported in this package using a verification endpoint. Add the following URL pattern:</p>
<pre><code class="language-python">    from rest_framework_jwt.views import verify_jwt_token

    #...

    urlpatterns = [
        #  ...
        url(r'^api-token-verify/', verify_jwt_token),
    ]
</code></pre>
<p>Passing a token to the verification endpoint will return a 200 response and the token if it is valid. Otherwise, it will return a 400 Bad Request as well as an error identifying why the token was invalid.</p>
<pre><code class="language-bash">$ curl -X POST -H &quot;Content-Type: application/json&quot; -d '{&quot;token&quot;:&quot;&lt;EXISTING_TOKEN&gt;&quot;}' http://localhost:8000/api-token-verify/
</code></pre>
<h2 id="impersonation-token">Impersonation Token</h2>
<p>Impersonation allows the service to perform actions on the client’s behalf. A typical use case would be troubleshooting. We can act like the user who submitted an issue without requiring its login credentials.</p>
<p>By default, only superusers (<code>user.is_superuser == True</code>) can impersonate other accounts. If you need to customize the permission handling process, override the <code>ImpersonateJSONWebTokenView</code>'s <a href="https://www.django-rest-framework.org/api-guide/permissions/#setting-the-permission-policy"><code>permission_classes</code> attribute</a>. </p>
<h2 id="blacklisting-tokens">Blacklisting Tokens</h2>
<p>Blacklisting allows users to blacklist their own token from the HTTP header or cookies. General
 use case is as a logout service.</p>
<p>There are two options for blacklisting tokens:
1. Using <em>Blacklist</em> as a logout service - make a POST request to the <code>BlacklistView</code> and the
 token will be retrieved from the request.
2. Blacklisting specific tokens - make a POST request to the <code>BlacklistView</code> with the body</p>
<pre><code>{'token' : '&lt;token_to_be_blacklisted&gt;'}
</code></pre>
<p>For example, your <code>urls.py</code> may look like:</p>
<pre><code class="language-python">from rest_framework_jwt.blacklist.views import BlacklistView
from rest_framework_jwt.views import obtain_jwt_token

urlpatterns = [
    path(&quot;auth/&quot;, obtain_jwt_token),
    path(&quot;auth/logout/&quot;, BlacklistView.as_view({&quot;post&quot;: &quot;create&quot;}))
]
</code></pre>
<h3 id="delete_stale_tokens-management-command"><code>delete_stale_tokens</code> management command</h3>
<p>When called, deletes all blacklisted tokens that have expired.</p>
<h3 id="warning">Warning</h3>
<p>Unless <code>JWT_TOKEN_ID</code> is set to <code>require</code>, blacklisting tokens will store the entire token value. This creates a potential problem if someone is able to read and delete records from the blacklist, either directly in the database or via the administrative interface. Note that the default value is <code>include</code>, not <code>require</code>. See the section on <code>JWT_TOKEN_ID</code> for how to migrate to requiring token id claims in all tokens.</p>
<h2 id="additional-settings">Additional Settings</h2>
<p>There are some additional settings that you can override similar to how you'd do it with Django REST framework itself. Here are all the available defaults.</p>
<pre><code class="language-python">JWT_AUTH = {
    'JWT_SECRET_KEY': settings.SECRET_KEY,
    'JWT_GET_USER_SECRET_KEY': None,
    'JWT_PRIVATE_KEY': None,
    'JWT_PUBLIC_KEY': None,
    'JWT_ALGORITHM': 'HS256',
    'JWT_INSIST_ON_KID': False,
    'JWT_TOKEN_ID': 'include',
    'JWT_AUDIENCE': None,
    'JWT_ISSUER': None,
    'JWT_ENCODE_HANDLER':
        'rest_framework_jwt.utils.jwt_encode_payload',
    'JWT_DECODE_HANDLER':
        'rest_framework_jwt.utils.jwt_decode_token',
    'JWT_PAYLOAD_HANDLER':
        'rest_framework_jwt.utils.jwt_create_payload',
    'JWT_PAYLOAD_GET_USERNAME_HANDLER':
        'rest_framework_jwt.utils.jwt_get_username_from_payload_handler',
    'JWT_PAYLOAD_INCLUDE_USER_ID': True,
    'JWT_VERIFY': True,
    'JWT_VERIFY_EXPIRATION': True,
    'JWT_LEEWAY': 0,
    'JWT_EXPIRATION_DELTA': datetime.timedelta(seconds=300),
    'JWT_ALLOW_REFRESH': True,
    'JWT_REFRESH_EXPIRATION_DELTA': datetime.timedelta(days=7),
    'JWT_AUTH_HEADER_PREFIX': 'Bearer',
    'JWT_RESPONSE_PAYLOAD_HANDLER':
        'rest_framework_jwt.utils.jwt_create_response_payload',
    'JWT_AUTH_COOKIE': None,
    'JWT_AUTH_COOKIE_DOMAIN': None,
    'JWT_AUTH_COOKIE_PATH': '/',
    'JWT_AUTH_COOKIE_SECURE': True,
    'JWT_AUTH_COOKIE_SAMESITE': 'Lax',
    'JWT_IMPERSONATION_COOKIE': None,
    'JWT_DELETE_STALE_BLACKLISTED_TOKENS': False,
}
</code></pre>
<p>This package uses the JSON Web Token Python implementation, <a href="https://github.com/jpadilla/pyjwt">PyJWT</a> and allows to modify some of its available options.</p>
<h3 id="jwt_secret_key">JWT_SECRET_KEY</h3>
<p>This is the secret key used to sign the JWT. Make sure this is safe and not shared or public.</p>
<p>Can be a dict, a list or a scalar.</p>
<ul>
<li>When a dict, the dict keys are taken as the JWT key ids and the values as
  keys, e.g.:</li>
</ul>
<p><code>python
  { "kid1": key1, "kid2": key2, ... }</code></p>
<p>The first element is used for signing.</p>
<p>If a JWT to be verified contains a key id (<code>kid</code> header), only the
  key with that id is tried (if any).</p>
<p><em>NOTE: For python &lt; 3.7, use a <code>collections.OrderedDict</code> object</em>, e.g.:</p>
<pre><code>```python
from collections import OrderedDict

JWT_AUTH["JWT_SECRET_KEY"] = OrderedDict(kid1=key1, kid2=key2, ...)
```
</code></pre>
<ul>
<li>
<p>When a list, all elements are accepted for verification and the
  first element is used for signing.</p>
</li>
<li>
<p>When a scalar, this secret is used for signing and verification.</p>
</li>
</ul>
<p>(The first) <code>JWT_SECRET_KEY</code> is only used for signing if (the first)
<code>JWT_ALGORITHM</code> is <code>HS*</code>, otherwise <code>JWT_PRIVATE_KEY</code> is used.</p>
<p><code>JWT_SECRET_KEY</code>(s) is/are only used for verification of JWTs with
<code>alg</code> matching <code>HS*</code></p>
<p>Default is your project's <code>settings.SECRET_KEY</code>.</p>
<h3 id="jwt_get_user_secret_key">JWT_GET_USER_SECRET_KEY</h3>
<p>This is more robust version of JWT_SECRET_KEY. It is defined per User, so in case token is compromised it can be
easily changed by owner. Changing this value will make all tokens for given user unusable. Value should be a function, accepting user as the only parameter and returning its secret key as string.</p>
<p>Default is <code>None</code>.</p>
<h3 id="jwt_private_key">JWT_PRIVATE_KEY</h3>
<p>Can be a scalar or a dict.</p>
<p>When a dict, the dict key is taken as the JWT key id and the values as
the key, e.g.:</p>
<pre><code class="language-python">{ &quot;kid&quot;: key }
</code></pre>
<p>The scalar or the dict value must be in any <a href="https://pyjwt.readthedocs.io/en/latest/algorithms.html">private key format supported by PyJWT</a>, for example of the types</p>
<ul>
<li><code>cryptography.hazmat.primitives.asymmetric.rsa.RSAPrivateKey</code></li>
<li><code>cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePrivateKey</code></li>
</ul>
<p>And will be used to sign the signature component of the JWT if <code>JWT_ALGORITHM</code> is set to any of the <a href="https://pyjwt.readthedocs.io/en/latest/algorithms.html">supported algorithms</a>  other than the hash types <code>HS*</code>.</p>
<p>Default is <code>None</code>.</p>
<h3 id="jwt_public_key">JWT_PUBLIC_KEY</h3>
<p>Can be a scalar, a list or a dict.</p>
<ul>
<li>When a dict, the dict keys are taken as the JWT key ids and the values as
  keys, e.g.:</li>
</ul>
<p><code>python
  { "kid1": key1, "kid2": key2, ... }</code></p>
<p>If a JWT that contains a key id (kid header) is to be verified, only
  the associated key is tried. Otherwise, or</p>
<ul>
<li>when a list, all of the elements will be accepted for verification of JWTs with <code>alg</code> being (any of) <code>JWT_ALGORITHM</code> not matching <code>HS*</code>.</li>
</ul>
<p>The scalar or elements/values of the list/dict must be in any <a href="https://pyjwt.readthedocs.io/en/latest/algorithms.html">public key format supported by PyJWT</a>, for example of the types</p>
<ul>
<li><code>cryptography.hazmat.primitives.asymmetric.rsa.RSAPublicKey</code></li>
<li><code>cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePublicKey</code></li>
</ul>
<p>Default is <code>None</code>.</p>
<h3 id="jwt_algorithm">JWT_ALGORITHM</h3>
<p>Possible values are any of the <a href="https://pyjwt.readthedocs.io/en/latest/algorithms.html">supported algorithms</a> for cryptographic signing in <code>PyJWT</code>.</p>
<p>Can be a scalar or a list.</p>
<ul>
<li>
<p>For a scalar, this algorithm is used for signing and verification.</p>
</li>
<li>
<p>For a list, the first element is used for signing and all elements are accepted for verification.</p>
</li>
</ul>
<p>Default is <code>"HS256"</code>.</p>
<h3 id="jwt_insist_on_kid">JWT_INSIST_ON_KID</h3>
<p>When key IDs are used (<code>JWT_SECRET_KEY</code> and/or <code>JWT_PUBLIC_KEY</code> given
as a dict assigning key IDs to keys), insist that JWTs to be validated
have a <code>kid</code> header with a defined key.</p>
<p>Default is <code>False</code>.</p>
<h3 id="jwt_token_id">JWT_TOKEN_ID</h3>
<p>Configure whether tokens have a <code>jti</code> token id claim (and refreshed tokens have a <code>orig_jti</code> claim).</p>
<p>May be set to:</p>
<ul>
<li><code>off</code>: do not include token id claims in tokens</li>
<li><code>include</code>: add token id claims to tokens, but continue accepting old tokens without them</li>
<li><code>require</code>: add token id claims to tokens, and reject tokens that lack them</li>
</ul>
<p>The default has been to include these claims since version 1.17.</p>
<p>For new installations, please override the default and set this to <code>require</code>, as every token will have an id from the outset.</p>
<p>For existing installations, when migrating from an older version (pre-1.17) or when changing the setting from <code>off</code>, we recommend setting this to <code>require</code> once all of the valid tokens have the id claims. This will typically be after <code>JWT_EXPIRATION_DELTA</code> has elapsed since upgrading or allowing id claims to be included.</p>
<p>Note that when set to <code>off</code> or <code>include</code>, the blacklist functionality - if used - will store the entire token value, which would allow someone with access to the administrative interface, or directly to the database, to steal an otherwise valid token and remove it from the blacklist. Using <code>require</code> for this setting means that only token identifiers are recorded for the blacklist and not entire tokens.</p>
<p>Default is <code>include</code>.</p>
<h3 id="jwt_audience">JWT_AUDIENCE</h3>
<p>This is a string that will be checked against the <code>aud</code> field of the token, if present.</p>
<p>Default is <code>None</code> (fail if <code>aud</code> present on JWT).</p>
<h3 id="jwt_issuer">JWT_ISSUER</h3>
<p>This is a string that will be checked against the <code>iss</code> field of the token.</p>
<p>Default is <code>None</code> (do not check <code>iss</code> on JWT).</p>
<h3 id="jwt_encode_handler">JWT_ENCODE_HANDLER</h3>
<p>Encodes JWT payload data and returns JWT token.</p>
<h3 id="jwt_decode_handler">JWT_DECODE_HANDLER</h3>
<p>Decodes JWT token and returns JWT payload data.</p>
<h3 id="jwt_payload_handler">JWT_PAYLOAD_HANDLER</h3>
<p>Specify a custom function to generate the token payload</p>
<h3 id="jwt_payload_get_username_handler">JWT_PAYLOAD_GET_USERNAME_HANDLER</h3>
<p>If you store <code>username</code> differently than the default payload handler does, implement this function to fetch <code>username</code> from the payload.</p>
<h3 id="jwt_payload_include_user_id">JWT_PAYLOAD_INCLUDE_USER_ID</h3>
<p>If you do not wish to include the user's primary key (typically <code>id</code>) in the token payload, then set this to <code>False</code>.</p>
<p>Default is <code>True</code>.</p>
<h3 id="jwt_verify">JWT_VERIFY</h3>
<p>If the secret is wrong, it will raise a <code>jwt.DecodeError</code>. You can still get the payload by setting the <code>JWT_VERIFY</code> to <code>False</code>.</p>
<p>Default is <code>True</code>.</p>
<h3 id="jwt_verify_expiration">JWT_VERIFY_EXPIRATION</h3>
<p>You can turn off expiration time verification by setting <code>JWT_VERIFY_EXPIRATION</code> to <code>False</code>.
Without expiration verification, JWTs will last forever meaning a leaked token could be used by an attacker indefinitely.</p>
<p>Default is <code>True</code>.</p>
<h3 id="jwt_leeway">JWT_LEEWAY</h3>
<p>This allows you to validate an expiration time which is in the past but not very far. For example, if you have a JWT payload with an expiration time set to 30 seconds after creation but you know that sometimes you will process it after 30 seconds, you can set a leeway of 10 seconds in order to have some margin.</p>
<p>Default is <code>0</code> seconds.</p>
<h3 id="jwt_expiration_delta">JWT_EXPIRATION_DELTA</h3>
<p>This is an instance of Python's <code>datetime.timedelta</code>. This will be added to <code>datetime.utcnow()</code> to set the expiration time.</p>
<p>Default is <code>datetime.timedelta(seconds=300)</code> (5 minutes).</p>
<h3 id="jwt_allow_refresh">JWT_ALLOW_REFRESH</h3>
<p>Enable token refresh functionality. Token issued from <code>rest_framework_jwt.views.obtain_jwt_token</code> will have an <code>orig_iat</code> field.</p>
<p>Default is <code>True</code>.</p>
<h3 id="jwt_refresh_expiration_delta">JWT_REFRESH_EXPIRATION_DELTA</h3>
<p>Limit on token refresh, is a <code>datetime.timedelta</code> instance. This is how much time after the original token that future tokens can be refreshed from.</p>
<p>Default is <code>datetime.timedelta(days=7)</code> (7 days).</p>
<h3 id="jwt_auth_header_prefix">JWT_AUTH_HEADER_PREFIX</h3>
<p>You can modify the Authorization header value prefix that is required to be sent together with the token.</p>
<p>Default value is <code>Bearer</code>.</p>
<h3 id="jwt_response_payload_handler">JWT_RESPONSE_PAYLOAD_HANDLER</h3>
<p>Creates a response payload instance that will get passed to authentication response serializer.
You might want to implement your own handler if you use custom response serializer (typical use-case would be including serialized <code>user</code> object in response).</p>
<p>By default returns a <code>namedtuple</code> with attributes <code>pk</code> (issued-at time) and <code>token</code>.</p>
<p>Example:</p>
<pre><code>def jwt_create_response_payload(token, user=None, request=None, issued_at=None):
    &quot;&quot;&quot;
    Return data ready to be passed to serializer.

    Override this function if you need to include any additional data for
    serializer.

    Note that we are using `pk` field here - this is for forward compatibility
    with drf add-ons that might require `pk` field in order (eg. jsonapi).
    &quot;&quot;&quot;

    response_payload = namedtuple('ResponsePayload', 'pk token user')
    response_payload.pk = issued_at
    response_payload.token = token
    response_payload.user = user

    return response_payload
</code></pre>
<h3 id="jwt_auth_cookie">JWT_AUTH_COOKIE</h3>
<p>You can set this to a string if you want to use http cookies in addition to the Authorization header as a valid transport for the token.
The string you set here will be used as the cookie name that will be set in the response headers when requesting a token. The token validation
procedure will also look into this cookie, if set. The 'Authorization' header takes precedence if both the header and the cookie are present in the request.</p>
<p>Default is <code>None</code> and no cookie is set when creating tokens nor accepted when validating them.</p>
<h3 id="jwt_auth_cookie_domain">JWT_AUTH_COOKIE_DOMAIN</h3>
<p>Default: <code>None</code></p>
<p>The domain to use for the JWT cookie analogous to
<code>SESSION_COOKIE_DOMAIN</code> for django sessions.</p>
<p>Has no effect unless JWT_AUTH_COOKIE is set.</p>
<h3 id="jwt_auth_cookie_path">JWT_AUTH_COOKIE_PATH</h3>
<p>Default: <code>/</code></p>
<p>The path to set on the JWT cookie analogous to <code>SESSION_COOKIE_PATH</code>
for django sessions.</p>
<p>Has no effect unless JWT_AUTH_COOKIE is set.</p>
<h3 id="jwt_auth_cookie_secure">JWT_AUTH_COOKIE_SECURE</h3>
<p>Default: <code>True</code></p>
<p>Whether to use a secure cookie for the JWT cookie analogous to
<code>SESSION_COOKIE_SECURE</code> for django sessions.</p>
<p>Users wishing to use JWT cookies over http (as in no TLS/SSL) need to
set <code>JWT_AUTH_COOKIE_SECURE</code> to <code>False.</code></p>
<p>Has no effect unless JWT_AUTH_COOKIE is set.</p>
<h3 id="jwt_auth_cookie_samesite">JWT_AUTH_COOKIE_SAMESITE</h3>
<p>Default: <code>Lax</code></p>
<p>The value of the <code>SameSite</code> flag on the the JWT cookie analogous to
<code>SESSION_COOKIE_SAMESITE</code> for django sessions.</p>
<p>Has no effect unless JWT_AUTH_COOKIE is set.</p>
<p>Has no effect with Django versions before 2.1.</p>
<h3 id="jwt_impersonation_cookie">JWT_IMPERSONATION_COOKIE</h3>
<p>Analogous to the <code>JWT_AUTH_COOKIE</code> setting, but contains the impersonation token, i.e. the token of the user who is being impersonated.</p>
<p>This cookie takes precedence over the <code>JWT_AUTH_COOKIE</code>. If you have both cookies and you want to end the impersonation, you have to remove the cookie. </p>
<p>Impersonation cookies use the <code>JWT_AUTH_COOKIE_*</code> settings.</p>
<h3 id="jwt_delete_stale_blacklisted_tokens">JWT_DELETE_STALE_BLACKLISTED_TOKENS</h3>
<p>Enables deleting of stale blacklisted tokens on <code>post_save</code> when set to <code>True</code>. All blacklisted
 tokens that have expired will be deleted.</p>
<p>Default is <code>False</code>.</p>
<h2 id="extendingoverriding-jsonwebtokenauthentication">Extending/Overriding <code>JSONWebTokenAuthentication</code></h2>
<p>Right now <code>JSONWebTokenAuthentication</code> assumes that the JWT will come in the header, or a cookie if configured (see <a href="#JWT_AUTH_COOKIE">JWT_AUTH_COOKIE</a>). The JWT spec does not require this (see: <a href="https://developer.atlassian.com/static/connect/docs/concepts/authentication.html">Making a service Call</a>). For example, the JWT may come in the querystring. The ability to send the JWT in the querystring is needed in cases where the user cannot set the header (for example the src element in HTML).</p>
<p>To achieve this functionality, the user might write a custom <code>Authentication</code> class:</p>
<pre><code class="language-python">class JSONWebTokenAuthenticationQS(JSONWebTokenAuthentication):

    def get_jwt_value(self, request):
        return request.QUERY_PARAMS.get('jwt')
</code></pre>
<h2 id="creating-a-new-token-manually">Creating a new token manually</h2>
<p>Sometimes you may want to manually generate a token, for example to return a token to the user immediately after account creation. You can do this as follows:</p>
<pre><code class="language-python">from rest_framework_jwt.settings import api_settings

jwt_payload_handler = api_settings.JWT_PAYLOAD_HANDLER
jwt_encode_handler = api_settings.JWT_ENCODE_HANDLER

payload = jwt_payload_handler(user)
token = jwt_encode_handler(payload)
</code></pre>
<h2 id="creating-a-new-token-on-the-command-line">Creating a new token on the command line</h2>
<p>There is a management command which you can use to obtain a JWT token, for example:</p>
<pre><code class="language-bash">python manage.py obtain_token username=John
# or
python manage.py obtain_token pk=1
</code></pre>
<p>it could be easier during development, to run this management command instead of using login API. </p>
              
            </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
    <!-- Copyright etc -->
    </p>
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
	  
        </div>
      </div>

    </section>

  </div>

<div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
          <a class="icon icon-github" style="float: left; color: #fcfcfc"> GitHub</a>
      
      
      
    </span>
</div>

</body>
</html>

<!--
MkDocs version : 0.13.2
Build Date UTC : 2021-03-18 13:37:48.909186
-->
