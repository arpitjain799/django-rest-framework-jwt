{
    "docs": [
        {
            "location": "/",
            "text": "REST framework JWT Auth\n\n\nJSON Web Token Authentication support for Django REST Framework\n\n\nOverview\n\n\nThis package provides \nJSON Web Token Authentication\n support for \nDjango REST framework\n.\n\n\nIf you want to know more about JWT, check out the following resources:\n\n\n\n\nDjangoCon 2014 - JSON Web Tokens \nVideo\n | \nSlides\n\n\nAuth with JSON Web Tokens\n\n\nJWT.io\n\n\n\n\nRequirements\n\n\n\n\nPython 2.7, 3.4+\n\n\nDjango 1.11+\n\n\nDjango REST Framework 3.7+\n\n\n\n\nSecurity\n\n\nUnlike some more typical uses of JWTs, this module only generates\nauthentication tokens that will verify the user who is requesting one of your DRF\nprotected API resources. The actual\nrequest parameters themselves are \nnot\n included in the JWT claims which means\nthey are not signed and may be tampered with. You should only expose your API\nendpoints over SSL/TLS to protect against content tampering and certain kinds of\nreplay attacks.\n\n\nInstallation\n\n\nInstall using \npip\n...\n\n\n$ pip install drf-jwt\n\n\n\nAdd the app to your project:\n\n\nINSTALLED_APPS = [\n    ...\n    'rest_framework_jwt',\n    'rest_framework_jwt.blacklist',\n    ...\n]\n\n\n\nNote the \nblacklist\n app in \nINSTALLED_APPS\n. You have to add it even if you dont't use\n the feature to avoid DB issues.\n\n\nUsage\n\n\nIn your \nsettings.py\n, add \nJSONWebTokenAuthentication\n to Django REST framework's \nDEFAULT_AUTHENTICATION_CLASSES\n.\n\n\nREST_FRAMEWORK = {\n    'DEFAULT_PERMISSION_CLASSES': (\n        'rest_framework.permissions.IsAuthenticated',\n    ),\n    'DEFAULT_AUTHENTICATION_CLASSES': (\n        'rest_framework_jwt.authentication.JSONWebTokenAuthentication',\n        'rest_framework.authentication.SessionAuthentication',\n        'rest_framework.authentication.BasicAuthentication',\n    ),\n}\n\n\n\nIn your \nurls.py\n add the following URL route to enable obtaining a token via a POST included the user's username and password.\n\n\nfrom rest_framework_jwt.views import obtain_jwt_token\n#...\n\nurlpatterns = [\n    '',\n    # ...\n\n    url(r'^api-token-auth/', obtain_jwt_token),\n]\n\n\n\nYou can easily test if the endpoint is working by doing the following in your terminal, if you had a user created with the username \nadmin\n and password \npassword123\n.\n\n\n$ curl -X POST -d \"username=admin&password=password123\" http://localhost:8000/api-token-auth/\n\n\n\nAlternatively, you can use all the content types supported by the Django REST framework to obtain the auth token. For example:\n\n\n$ curl -X POST -H \"Content-Type: application/json\" -d '{\"username\":\"admin\",\"password\":\"password123\"}' http://localhost:8000/api-token-auth/\n\n\n\nNow in order to access protected api urls you must include the \nAuthorization: Bearer <your_token>\n header.\n\n\n$ curl -H \"Authorization: Bearer <your_token>\" http://localhost:8000/protected-url/\n\n\n\nIn addition to adding the Authorization: Bearer in your requests, make sure that you have decorated your views properly. For this, import the \nJSONWebTokenAuthentication\n authentication class from \nrest_framework_jwt.authentication\n\n\nfrom rest_framework_jwt.authentication import JSONWebTokenAuthentication\n\n\n\nIf you are using django's function based views, then you should decorate your views with the authentication_classes decorator containing JSONWebTokenAuthentication as follows:\n\n\n...\n@authentication_classes([JSONWebTokenAuthentication])\ndef protectedView(request):\n    ...\n\n\n\nIn case you are using class based views, you should override the \nauthentication_classes\n attribute in the view like so:\n\n\nclass ExampleView(APIView):\n    ...\n    authentication_classes = [JSONWebTokenAuthentication]\n    ...\n\n\n\nThis is necessary if the \nJSONWebTokenAuthentication\n class wasn't added to the \nDEFAULT_AUTHENTICATION_CLASSES\n, or if JWT authentication is needed \nonly\n on certain views. If you have added it to \nDEFAULT_AUTHENTICATION_CLASSES\n, then the views will be authenticated using JWT authentication automatically.\n\n\nRefresh Token\n\n\nIf \nJWT_ALLOW_REFRESH\n is True, \nnon-expired\n tokens can be \"refreshed\" to obtain a brand new token with renewed expiration time. Add a URL pattern like this:\n\n\n    from rest_framework_jwt.views import refresh_jwt_token\n    #  ...\n\n    urlpatterns = [\n        #  ...\n        url(r'^api-token-refresh/', refresh_jwt_token),\n    ]\n\n\n\nPass in an existing token to the refresh endpoint as follows: \n{\"token\": EXISTING_TOKEN}\n. Note that only non-expired tokens will work. The JSON response looks the same as the normal obtain token endpoint \n{\"token\": NEW_TOKEN}\n.\n\n\n$ curl -X POST -H \"Content-Type: application/json\" -d '{\"token\":\"<EXISTING_TOKEN>\"}' http://localhost:8000/api-token-refresh/\n\n\n\nRefresh with tokens can be repeated (token1 -> token2 -> token3), but this chain of token stores the time that the original token (obtained with username/password credentials), as \norig_iat\n. You can only keep refreshing tokens up to \nJWT_REFRESH_EXPIRATION_DELTA\n.\n\n\nA typical use case might be a web app where you'd like to keep the user \"logged in\" the site without having to re-enter their password, or get kicked out by surprise before their token expired. Imagine they had a 1-hour token and are just at the last minute while they're still doing something. With mobile you could perhaps store the username/password to get a new token, but this is not a great idea in a browser. Each time the user loads the page, you can check if there is an existing non-expired token and if it's close to being expired, refresh it to extend their session. In other words, if a user is actively using your site, they can keep their \"session\" alive.\n\n\nVerify Token\n\n\nIn some microservice architectures, authentication is handled by a single service. Other services delegate the responsibility of confirming that a user is logged in to this authentication service. This usually means that a service will pass a JWT received from the user to the authentication service, and wait for a confirmation that the JWT is valid before returning protected resources to the user.\n\n\nThis setup is supported in this package using a verification endpoint. Add the following URL pattern:\n\n\n    from rest_framework_jwt.views import verify_jwt_token\n\n    #...\n\n    urlpatterns = [\n        #  ...\n        url(r'^api-token-verify/', verify_jwt_token),\n    ]\n\n\n\nPassing a token to the verification endpoint will return a 200 response and the token if it is valid. Otherwise, it will return a 400 Bad Request as well as an error identifying why the token was invalid.\n\n\n$ curl -X POST -H \"Content-Type: application/json\" -d '{\"token\":\"<EXISTING_TOKEN>\"}' http://localhost:8000/api-token-verify/\n\n\n\nImpersonation Token\n\n\nImpersonation allows the service to perform actions on the client\u2019s behalf. A typical use case would be troubleshooting. We can act like the user who submitted an issue without requiring its login credentials.\n\n\nBy default, only superusers (\nuser.is_superuser == True\n) can impersonate other accounts. If you need to customize the permission handling process, override the \nImpersonateJSONWebTokenView\n's \npermission_classes\n attribute\n. \n\n\nBlacklisting Tokens\n\n\nBlacklisting allows users to blacklist their own token from the HTTP header or cookies. General\n use case is as a logout service.\n\n\nThere are two options for blacklisting tokens:\n1. Using \nBlacklist\n as a logout service - make a POST request to the \nBlacklistView\n and the\n token will be retrieved from the request.\n2. Blacklisting specific tokens - make a POST request to the \nBlacklistView\n with the body\n\n\n{'token' : '<token_to_be_blacklisted>'}\n\n\n\nFor example, your \nurls.py\n may look like:\n\n\nfrom rest_framework_jwt.blacklist.views import BlacklistView\nfrom rest_framework_jwt.views import obtain_jwt_token\n\nurlpatterns = [\n    path(\"auth/\", obtain_jwt_token),\n    path(\"auth/logout/\", BlacklistView.as_view({\"post\": \"create\"}))\n]\n\n\n\ndelete_stale_tokens\n management command\n\n\nWhen called, deletes all blacklisted tokens that have expired.\n\n\nWarning\n\n\nUnless \nJWT_TOKEN_ID\n is set to \nrequire\n, blacklisting tokens will store the entire token value. This creates a potential problem if someone is able to read and delete records from the blacklist, either directly in the database or via the administrative interface. Note that the default value is \ninclude\n, not \nrequire\n. See the section on \nJWT_TOKEN_ID\n for how to migrate to requiring token id claims in all tokens.\n\n\nAdditional Settings\n\n\nThere are some additional settings that you can override similar to how you'd do it with Django REST framework itself. Here are all the available defaults.\n\n\nJWT_AUTH = {\n    'JWT_SECRET_KEY': settings.SECRET_KEY,\n    'JWT_GET_USER_SECRET_KEY': None,\n    'JWT_PRIVATE_KEY': None,\n    'JWT_PUBLIC_KEY': None,\n    'JWT_ALGORITHM': 'HS256',\n    'JWT_INSIST_ON_KID': False,\n    'JWT_TOKEN_ID': 'include',\n    'JWT_AUDIENCE': None,\n    'JWT_ISSUER': None,\n    'JWT_ENCODE_HANDLER':\n        'rest_framework_jwt.utils.jwt_encode_payload',\n    'JWT_DECODE_HANDLER':\n        'rest_framework_jwt.utils.jwt_decode_token',\n    'JWT_PAYLOAD_HANDLER':\n        'rest_framework_jwt.utils.jwt_create_payload',\n    'JWT_PAYLOAD_GET_USERNAME_HANDLER':\n        'rest_framework_jwt.utils.jwt_get_username_from_payload_handler',\n    'JWT_PAYLOAD_INCLUDE_USER_ID': True,\n    'JWT_VERIFY': True,\n    'JWT_VERIFY_EXPIRATION': True,\n    'JWT_LEEWAY': 0,\n    'JWT_EXPIRATION_DELTA': datetime.timedelta(seconds=300),\n    'JWT_ALLOW_REFRESH': True,\n    'JWT_REFRESH_EXPIRATION_DELTA': datetime.timedelta(days=7),\n    'JWT_AUTH_HEADER_PREFIX': 'Bearer',\n    'JWT_RESPONSE_PAYLOAD_HANDLER':\n        'rest_framework_jwt.utils.jwt_create_response_payload',\n    'JWT_AUTH_COOKIE': None,\n    'JWT_AUTH_COOKIE_DOMAIN': None,\n    'JWT_AUTH_COOKIE_PATH': '/',\n    'JWT_AUTH_COOKIE_SECURE': True,\n    'JWT_AUTH_COOKIE_SAMESITE': 'Lax',\n    'JWT_IMPERSONATION_COOKIE': None,\n    'JWT_DELETE_STALE_BLACKLISTED_TOKENS': False,\n}\n\n\n\nThis package uses the JSON Web Token Python implementation, \nPyJWT\n and allows to modify some of its available options.\n\n\nJWT_SECRET_KEY\n\n\nThis is the secret key used to sign the JWT. Make sure this is safe and not shared or public.\n\n\nCan be a dict, a list or a scalar.\n\n\n\n\nWhen a dict, the dict keys are taken as the JWT key ids and the values as\n  keys, e.g.:\n\n\n\n\npython\n  { \"kid1\": key1, \"kid2\": key2, ... }\n\n\nThe first element is used for signing.\n\n\nIf a JWT to be verified contains a key id (\nkid\n header), only the\n  key with that id is tried (if any).\n\n\nNOTE: For python < 3.7, use a \ncollections.OrderedDict\n object\n, e.g.:\n\n\n```python\nfrom collections import OrderedDict\n\nJWT_AUTH[\"JWT_SECRET_KEY\"] = OrderedDict(kid1=key1, kid2=key2, ...)\n```\n\n\n\n\n\n\n\nWhen a list, all elements are accepted for verification and the\n  first element is used for signing.\n\n\n\n\n\n\nWhen a scalar, this secret is used for signing and verification.\n\n\n\n\n\n\n(The first) \nJWT_SECRET_KEY\n is only used for signing if (the first)\n\nJWT_ALGORITHM\n is \nHS*\n, otherwise \nJWT_PRIVATE_KEY\n is used.\n\n\nJWT_SECRET_KEY\n(s) is/are only used for verification of JWTs with\n\nalg\n matching \nHS*\n\n\nDefault is your project's \nsettings.SECRET_KEY\n.\n\n\nJWT_GET_USER_SECRET_KEY\n\n\nThis is more robust version of JWT_SECRET_KEY. It is defined per User, so in case token is compromised it can be\neasily changed by owner. Changing this value will make all tokens for given user unusable. Value should be a function, accepting user as the only parameter and returning its secret key as string.\n\n\nDefault is \nNone\n.\n\n\nJWT_PRIVATE_KEY\n\n\nCan be a scalar or a dict.\n\n\nWhen a dict, the dict key is taken as the JWT key id and the values as\nthe key, e.g.:\n\n\n{ \"kid\": key }\n\n\n\nThe scalar or the dict value must be in any \nprivate key format supported by PyJWT\n, for example of the types\n\n\n\n\ncryptography.hazmat.primitives.asymmetric.rsa.RSAPrivateKey\n\n\ncryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePrivateKey\n\n\n\n\nAnd will be used to sign the signature component of the JWT if \nJWT_ALGORITHM\n is set to any of the \nsupported algorithms\n  other than the hash types \nHS*\n.\n\n\nDefault is \nNone\n.\n\n\nJWT_PUBLIC_KEY\n\n\nCan be a scalar, a list or a dict.\n\n\n\n\nWhen a dict, the dict keys are taken as the JWT key ids and the values as\n  keys, e.g.:\n\n\n\n\npython\n  { \"kid1\": key1, \"kid2\": key2, ... }\n\n\nIf a JWT that contains a key id (kid header) is to be verified, only\n  the associated key is tried. Otherwise, or\n\n\n\n\nwhen a list, all of the elements will be accepted for verification of JWTs with \nalg\n being (any of) \nJWT_ALGORITHM\n not matching \nHS*\n.\n\n\n\n\nThe scalar or elements/values of the list/dict must be in any \npublic key format supported by PyJWT\n, for example of the types\n\n\n\n\ncryptography.hazmat.primitives.asymmetric.rsa.RSAPublicKey\n\n\ncryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePublicKey\n\n\n\n\nDefault is \nNone\n.\n\n\nJWT_ALGORITHM\n\n\nPossible values are any of the \nsupported algorithms\n for cryptographic signing in \nPyJWT\n.\n\n\nCan be a scalar or a list.\n\n\n\n\n\n\nFor a scalar, this algorithm is used for signing and verification.\n\n\n\n\n\n\nFor a list, the first element is used for signing and all elements are accepted for verification.\n\n\n\n\n\n\nDefault is \n\"HS256\"\n.\n\n\nJWT_INSIST_ON_KID\n\n\nWhen key IDs are used (\nJWT_SECRET_KEY\n and/or \nJWT_PUBLIC_KEY\n given\nas a dict assigning key IDs to keys), insist that JWTs to be validated\nhave a \nkid\n header with a defined key.\n\n\nDefault is \nFalse\n.\n\n\nJWT_TOKEN_ID\n\n\nConfigure whether tokens have a \njti\n token id claim (and refreshed tokens have a \norig_jti\n claim).\n\n\nMay be set to:\n\n\n\n\noff\n: do not include token id claims in tokens\n\n\ninclude\n: add token id claims to tokens, but continue accepting old tokens without them\n\n\nrequire\n: add token id claims to tokens, and reject tokens that lack them\n\n\n\n\nThe default has been to include these claims since version 1.17.\n\n\nFor new installations, please override the default and set this to \nrequire\n, as every token will have an id from the outset.\n\n\nFor existing installations, when migrating from an older version (pre-1.17) or when changing the setting from \noff\n, we recommend setting this to \nrequire\n once all of the valid tokens have the id claims. This will typically be after \nJWT_EXPIRATION_DELTA\n has elapsed since upgrading or allowing id claims to be included.\n\n\nNote that when set to \noff\n or \ninclude\n, the blacklist functionality - if used - will store the entire token value, which would allow someone with access to the administrative interface, or directly to the database, to steal an otherwise valid token and remove it from the blacklist. Using \nrequire\n for this setting means that only token identifiers are recorded for the blacklist and not entire tokens.\n\n\nDefault is \ninclude\n.\n\n\nJWT_AUDIENCE\n\n\nThis is a string that will be checked against the \naud\n field of the token, if present.\n\n\nDefault is \nNone\n (fail if \naud\n present on JWT).\n\n\nJWT_ISSUER\n\n\nThis is a string that will be checked against the \niss\n field of the token.\n\n\nDefault is \nNone\n (do not check \niss\n on JWT).\n\n\nJWT_ENCODE_HANDLER\n\n\nEncodes JWT payload data and returns JWT token.\n\n\nJWT_DECODE_HANDLER\n\n\nDecodes JWT token and returns JWT payload data.\n\n\nJWT_PAYLOAD_HANDLER\n\n\nSpecify a custom function to generate the token payload\n\n\nJWT_PAYLOAD_GET_USERNAME_HANDLER\n\n\nIf you store \nusername\n differently than the default payload handler does, implement this function to fetch \nusername\n from the payload.\n\n\nJWT_PAYLOAD_INCLUDE_USER_ID\n\n\nIf you do not wish to include the user's primary key (typically \nid\n) in the token payload, then set this to \nFalse\n.\n\n\nDefault is \nTrue\n.\n\n\nJWT_VERIFY\n\n\nIf the secret is wrong, it will raise a \njwt.DecodeError\n. You can still get the payload by setting the \nJWT_VERIFY\n to \nFalse\n.\n\n\nDefault is \nTrue\n.\n\n\nJWT_VERIFY_EXPIRATION\n\n\nYou can turn off expiration time verification by setting \nJWT_VERIFY_EXPIRATION\n to \nFalse\n.\nWithout expiration verification, JWTs will last forever meaning a leaked token could be used by an attacker indefinitely.\n\n\nDefault is \nTrue\n.\n\n\nJWT_LEEWAY\n\n\nThis allows you to validate an expiration time which is in the past but not very far. For example, if you have a JWT payload with an expiration time set to 30 seconds after creation but you know that sometimes you will process it after 30 seconds, you can set a leeway of 10 seconds in order to have some margin.\n\n\nDefault is \n0\n seconds.\n\n\nJWT_EXPIRATION_DELTA\n\n\nThis is an instance of Python's \ndatetime.timedelta\n. This will be added to \ndatetime.utcnow()\n to set the expiration time.\n\n\nDefault is \ndatetime.timedelta(seconds=300)\n (5 minutes).\n\n\nJWT_ALLOW_REFRESH\n\n\nEnable token refresh functionality. Token issued from \nrest_framework_jwt.views.obtain_jwt_token\n will have an \norig_iat\n field.\n\n\nDefault is \nTrue\n.\n\n\nJWT_REFRESH_EXPIRATION_DELTA\n\n\nLimit on token refresh, is a \ndatetime.timedelta\n instance. This is how much time after the original token that future tokens can be refreshed from.\n\n\nDefault is \ndatetime.timedelta(days=7)\n (7 days).\n\n\nJWT_AUTH_HEADER_PREFIX\n\n\nYou can modify the Authorization header value prefix that is required to be sent together with the token.\n\n\nDefault value is \nBearer\n.\n\n\nJWT_RESPONSE_PAYLOAD_HANDLER\n\n\nCreates a response payload instance that will get passed to authentication response serializer.\nYou might want to implement your own handler if you use custom response serializer (typical use-case would be including serialized \nuser\n object in response).\n\n\nBy default returns a \nnamedtuple\n with attributes \npk\n (issued-at time) and \ntoken\n.\n\n\nExample:\n\n\ndef jwt_create_response_payload(token, user=None, request=None, issued_at=None):\n    \"\"\"\n    Return data ready to be passed to serializer.\n\n    Override this function if you need to include any additional data for\n    serializer.\n\n    Note that we are using `pk` field here - this is for forward compatibility\n    with drf add-ons that might require `pk` field in order (eg. jsonapi).\n    \"\"\"\n\n    response_payload = namedtuple('ResponsePayload', 'pk token user')\n    response_payload.pk = issued_at\n    response_payload.token = token\n    response_payload.user = user\n\n    return response_payload\n\n\n\nJWT_AUTH_COOKIE\n\n\nYou can set this to a string if you want to use http cookies in addition to the Authorization header as a valid transport for the token.\nThe string you set here will be used as the cookie name that will be set in the response headers when requesting a token. The token validation\nprocedure will also look into this cookie, if set. The 'Authorization' header takes precedence if both the header and the cookie are present in the request.\n\n\nDefault is \nNone\n and no cookie is set when creating tokens nor accepted when validating them.\n\n\nJWT_AUTH_COOKIE_DOMAIN\n\n\nDefault: \nNone\n\n\nThe domain to use for the JWT cookie analogous to\n\nSESSION_COOKIE_DOMAIN\n for django sessions.\n\n\nHas no effect unless JWT_AUTH_COOKIE is set.\n\n\nJWT_AUTH_COOKIE_PATH\n\n\nDefault: \n/\n\n\nThe path to set on the JWT cookie analogous to \nSESSION_COOKIE_PATH\n\nfor django sessions.\n\n\nHas no effect unless JWT_AUTH_COOKIE is set.\n\n\nJWT_AUTH_COOKIE_SECURE\n\n\nDefault: \nTrue\n\n\nWhether to use a secure cookie for the JWT cookie analogous to\n\nSESSION_COOKIE_SECURE\n for django sessions.\n\n\nUsers wishing to use JWT cookies over http (as in no TLS/SSL) need to\nset \nJWT_AUTH_COOKIE_SECURE\n to \nFalse.\n\n\nHas no effect unless JWT_AUTH_COOKIE is set.\n\n\nJWT_AUTH_COOKIE_SAMESITE\n\n\nDefault: \nLax\n\n\nThe value of the \nSameSite\n flag on the the JWT cookie analogous to\n\nSESSION_COOKIE_SAMESITE\n for django sessions.\n\n\nHas no effect unless JWT_AUTH_COOKIE is set.\n\n\nHas no effect with Django versions before 2.1.\n\n\nJWT_IMPERSONATION_COOKIE\n\n\nAnalogous to the \nJWT_AUTH_COOKIE\n setting, but contains the impersonation token, i.e. the token of the user who is being impersonated.\n\n\nThis cookie takes precedence over the \nJWT_AUTH_COOKIE\n. If you have both cookies and you want to end the impersonation, you have to remove the cookie. \n\n\nImpersonation cookies use the \nJWT_AUTH_COOKIE_*\n settings.\n\n\nJWT_DELETE_STALE_BLACKLISTED_TOKENS\n\n\nEnables deleting of stale blacklisted tokens on \npost_save\n when set to \nTrue\n. All blacklisted\n tokens that have expired will be deleted.\n\n\nDefault is \nFalse\n.\n\n\nExtending/Overriding \nJSONWebTokenAuthentication\n\n\nRight now \nJSONWebTokenAuthentication\n assumes that the JWT will come in the header, or a cookie if configured (see \nJWT_AUTH_COOKIE\n). The JWT spec does not require this (see: \nMaking a service Call\n). For example, the JWT may come in the querystring. The ability to send the JWT in the querystring is needed in cases where the user cannot set the header (for example the src element in HTML).\n\n\nTo achieve this functionality, the user might write a custom \nAuthentication\n class:\n\n\nclass JSONWebTokenAuthenticationQS(JSONWebTokenAuthentication):\n\n    def get_jwt_value(self, request):\n        return request.QUERY_PARAMS.get('jwt')\n\n\n\nCreating a new token manually\n\n\nSometimes you may want to manually generate a token, for example to return a token to the user immediately after account creation. You can do this as follows:\n\n\nfrom rest_framework_jwt.settings import api_settings\n\njwt_payload_handler = api_settings.JWT_PAYLOAD_HANDLER\njwt_encode_handler = api_settings.JWT_ENCODE_HANDLER\n\npayload = jwt_payload_handler(user)\ntoken = jwt_encode_handler(payload)\n\n\n\nCreating a new token on the command line\n\n\nThere is a management command which you can use to obtain a JWT token, for example:\n\n\npython manage.py obtain_token username=John\n# or\npython manage.py obtain_token pk=1\n\n\n\nit could be easier during development, to run this management command instead of using login API.",
            "title": "Home"
        },
        {
            "location": "/#rest-framework-jwt-auth",
            "text": "JSON Web Token Authentication support for Django REST Framework",
            "title": "REST framework JWT Auth"
        },
        {
            "location": "/#overview",
            "text": "This package provides  JSON Web Token Authentication  support for  Django REST framework .  If you want to know more about JWT, check out the following resources:   DjangoCon 2014 - JSON Web Tokens  Video  |  Slides  Auth with JSON Web Tokens  JWT.io",
            "title": "Overview"
        },
        {
            "location": "/#requirements",
            "text": "Python 2.7, 3.4+  Django 1.11+  Django REST Framework 3.7+",
            "title": "Requirements"
        },
        {
            "location": "/#security",
            "text": "Unlike some more typical uses of JWTs, this module only generates\nauthentication tokens that will verify the user who is requesting one of your DRF\nprotected API resources. The actual\nrequest parameters themselves are  not  included in the JWT claims which means\nthey are not signed and may be tampered with. You should only expose your API\nendpoints over SSL/TLS to protect against content tampering and certain kinds of\nreplay attacks.",
            "title": "Security"
        },
        {
            "location": "/#installation",
            "text": "Install using  pip ...  $ pip install drf-jwt  Add the app to your project:  INSTALLED_APPS = [\n    ...\n    'rest_framework_jwt',\n    'rest_framework_jwt.blacklist',\n    ...\n]  Note the  blacklist  app in  INSTALLED_APPS . You have to add it even if you dont't use\n the feature to avoid DB issues.",
            "title": "Installation"
        },
        {
            "location": "/#usage",
            "text": "In your  settings.py , add  JSONWebTokenAuthentication  to Django REST framework's  DEFAULT_AUTHENTICATION_CLASSES .  REST_FRAMEWORK = {\n    'DEFAULT_PERMISSION_CLASSES': (\n        'rest_framework.permissions.IsAuthenticated',\n    ),\n    'DEFAULT_AUTHENTICATION_CLASSES': (\n        'rest_framework_jwt.authentication.JSONWebTokenAuthentication',\n        'rest_framework.authentication.SessionAuthentication',\n        'rest_framework.authentication.BasicAuthentication',\n    ),\n}  In your  urls.py  add the following URL route to enable obtaining a token via a POST included the user's username and password.  from rest_framework_jwt.views import obtain_jwt_token\n#...\n\nurlpatterns = [\n    '',\n    # ...\n\n    url(r'^api-token-auth/', obtain_jwt_token),\n]  You can easily test if the endpoint is working by doing the following in your terminal, if you had a user created with the username  admin  and password  password123 .  $ curl -X POST -d \"username=admin&password=password123\" http://localhost:8000/api-token-auth/  Alternatively, you can use all the content types supported by the Django REST framework to obtain the auth token. For example:  $ curl -X POST -H \"Content-Type: application/json\" -d '{\"username\":\"admin\",\"password\":\"password123\"}' http://localhost:8000/api-token-auth/  Now in order to access protected api urls you must include the  Authorization: Bearer <your_token>  header.  $ curl -H \"Authorization: Bearer <your_token>\" http://localhost:8000/protected-url/  In addition to adding the Authorization: Bearer in your requests, make sure that you have decorated your views properly. For this, import the  JSONWebTokenAuthentication  authentication class from  rest_framework_jwt.authentication  from rest_framework_jwt.authentication import JSONWebTokenAuthentication  If you are using django's function based views, then you should decorate your views with the authentication_classes decorator containing JSONWebTokenAuthentication as follows:  ...\n@authentication_classes([JSONWebTokenAuthentication])\ndef protectedView(request):\n    ...  In case you are using class based views, you should override the  authentication_classes  attribute in the view like so:  class ExampleView(APIView):\n    ...\n    authentication_classes = [JSONWebTokenAuthentication]\n    ...  This is necessary if the  JSONWebTokenAuthentication  class wasn't added to the  DEFAULT_AUTHENTICATION_CLASSES , or if JWT authentication is needed  only  on certain views. If you have added it to  DEFAULT_AUTHENTICATION_CLASSES , then the views will be authenticated using JWT authentication automatically.",
            "title": "Usage"
        },
        {
            "location": "/#refresh-token",
            "text": "If  JWT_ALLOW_REFRESH  is True,  non-expired  tokens can be \"refreshed\" to obtain a brand new token with renewed expiration time. Add a URL pattern like this:      from rest_framework_jwt.views import refresh_jwt_token\n    #  ...\n\n    urlpatterns = [\n        #  ...\n        url(r'^api-token-refresh/', refresh_jwt_token),\n    ]  Pass in an existing token to the refresh endpoint as follows:  {\"token\": EXISTING_TOKEN} . Note that only non-expired tokens will work. The JSON response looks the same as the normal obtain token endpoint  {\"token\": NEW_TOKEN} .  $ curl -X POST -H \"Content-Type: application/json\" -d '{\"token\":\"<EXISTING_TOKEN>\"}' http://localhost:8000/api-token-refresh/  Refresh with tokens can be repeated (token1 -> token2 -> token3), but this chain of token stores the time that the original token (obtained with username/password credentials), as  orig_iat . You can only keep refreshing tokens up to  JWT_REFRESH_EXPIRATION_DELTA .  A typical use case might be a web app where you'd like to keep the user \"logged in\" the site without having to re-enter their password, or get kicked out by surprise before their token expired. Imagine they had a 1-hour token and are just at the last minute while they're still doing something. With mobile you could perhaps store the username/password to get a new token, but this is not a great idea in a browser. Each time the user loads the page, you can check if there is an existing non-expired token and if it's close to being expired, refresh it to extend their session. In other words, if a user is actively using your site, they can keep their \"session\" alive.",
            "title": "Refresh Token"
        },
        {
            "location": "/#verify-token",
            "text": "In some microservice architectures, authentication is handled by a single service. Other services delegate the responsibility of confirming that a user is logged in to this authentication service. This usually means that a service will pass a JWT received from the user to the authentication service, and wait for a confirmation that the JWT is valid before returning protected resources to the user.  This setup is supported in this package using a verification endpoint. Add the following URL pattern:      from rest_framework_jwt.views import verify_jwt_token\n\n    #...\n\n    urlpatterns = [\n        #  ...\n        url(r'^api-token-verify/', verify_jwt_token),\n    ]  Passing a token to the verification endpoint will return a 200 response and the token if it is valid. Otherwise, it will return a 400 Bad Request as well as an error identifying why the token was invalid.  $ curl -X POST -H \"Content-Type: application/json\" -d '{\"token\":\"<EXISTING_TOKEN>\"}' http://localhost:8000/api-token-verify/",
            "title": "Verify Token"
        },
        {
            "location": "/#impersonation-token",
            "text": "Impersonation allows the service to perform actions on the client\u2019s behalf. A typical use case would be troubleshooting. We can act like the user who submitted an issue without requiring its login credentials.  By default, only superusers ( user.is_superuser == True ) can impersonate other accounts. If you need to customize the permission handling process, override the  ImpersonateJSONWebTokenView 's  permission_classes  attribute .",
            "title": "Impersonation Token"
        },
        {
            "location": "/#blacklisting-tokens",
            "text": "Blacklisting allows users to blacklist their own token from the HTTP header or cookies. General\n use case is as a logout service.  There are two options for blacklisting tokens:\n1. Using  Blacklist  as a logout service - make a POST request to the  BlacklistView  and the\n token will be retrieved from the request.\n2. Blacklisting specific tokens - make a POST request to the  BlacklistView  with the body  {'token' : '<token_to_be_blacklisted>'}  For example, your  urls.py  may look like:  from rest_framework_jwt.blacklist.views import BlacklistView\nfrom rest_framework_jwt.views import obtain_jwt_token\n\nurlpatterns = [\n    path(\"auth/\", obtain_jwt_token),\n    path(\"auth/logout/\", BlacklistView.as_view({\"post\": \"create\"}))\n]  delete_stale_tokens  management command  When called, deletes all blacklisted tokens that have expired.  Warning  Unless  JWT_TOKEN_ID  is set to  require , blacklisting tokens will store the entire token value. This creates a potential problem if someone is able to read and delete records from the blacklist, either directly in the database or via the administrative interface. Note that the default value is  include , not  require . See the section on  JWT_TOKEN_ID  for how to migrate to requiring token id claims in all tokens.",
            "title": "Blacklisting Tokens"
        },
        {
            "location": "/#additional-settings",
            "text": "There are some additional settings that you can override similar to how you'd do it with Django REST framework itself. Here are all the available defaults.  JWT_AUTH = {\n    'JWT_SECRET_KEY': settings.SECRET_KEY,\n    'JWT_GET_USER_SECRET_KEY': None,\n    'JWT_PRIVATE_KEY': None,\n    'JWT_PUBLIC_KEY': None,\n    'JWT_ALGORITHM': 'HS256',\n    'JWT_INSIST_ON_KID': False,\n    'JWT_TOKEN_ID': 'include',\n    'JWT_AUDIENCE': None,\n    'JWT_ISSUER': None,\n    'JWT_ENCODE_HANDLER':\n        'rest_framework_jwt.utils.jwt_encode_payload',\n    'JWT_DECODE_HANDLER':\n        'rest_framework_jwt.utils.jwt_decode_token',\n    'JWT_PAYLOAD_HANDLER':\n        'rest_framework_jwt.utils.jwt_create_payload',\n    'JWT_PAYLOAD_GET_USERNAME_HANDLER':\n        'rest_framework_jwt.utils.jwt_get_username_from_payload_handler',\n    'JWT_PAYLOAD_INCLUDE_USER_ID': True,\n    'JWT_VERIFY': True,\n    'JWT_VERIFY_EXPIRATION': True,\n    'JWT_LEEWAY': 0,\n    'JWT_EXPIRATION_DELTA': datetime.timedelta(seconds=300),\n    'JWT_ALLOW_REFRESH': True,\n    'JWT_REFRESH_EXPIRATION_DELTA': datetime.timedelta(days=7),\n    'JWT_AUTH_HEADER_PREFIX': 'Bearer',\n    'JWT_RESPONSE_PAYLOAD_HANDLER':\n        'rest_framework_jwt.utils.jwt_create_response_payload',\n    'JWT_AUTH_COOKIE': None,\n    'JWT_AUTH_COOKIE_DOMAIN': None,\n    'JWT_AUTH_COOKIE_PATH': '/',\n    'JWT_AUTH_COOKIE_SECURE': True,\n    'JWT_AUTH_COOKIE_SAMESITE': 'Lax',\n    'JWT_IMPERSONATION_COOKIE': None,\n    'JWT_DELETE_STALE_BLACKLISTED_TOKENS': False,\n}  This package uses the JSON Web Token Python implementation,  PyJWT  and allows to modify some of its available options.  JWT_SECRET_KEY  This is the secret key used to sign the JWT. Make sure this is safe and not shared or public.  Can be a dict, a list or a scalar.   When a dict, the dict keys are taken as the JWT key ids and the values as\n  keys, e.g.:   python\n  { \"kid1\": key1, \"kid2\": key2, ... }  The first element is used for signing.  If a JWT to be verified contains a key id ( kid  header), only the\n  key with that id is tried (if any).  NOTE: For python < 3.7, use a  collections.OrderedDict  object , e.g.:  ```python\nfrom collections import OrderedDict\n\nJWT_AUTH[\"JWT_SECRET_KEY\"] = OrderedDict(kid1=key1, kid2=key2, ...)\n```    When a list, all elements are accepted for verification and the\n  first element is used for signing.    When a scalar, this secret is used for signing and verification.    (The first)  JWT_SECRET_KEY  is only used for signing if (the first) JWT_ALGORITHM  is  HS* , otherwise  JWT_PRIVATE_KEY  is used.  JWT_SECRET_KEY (s) is/are only used for verification of JWTs with alg  matching  HS*  Default is your project's  settings.SECRET_KEY .  JWT_GET_USER_SECRET_KEY  This is more robust version of JWT_SECRET_KEY. It is defined per User, so in case token is compromised it can be\neasily changed by owner. Changing this value will make all tokens for given user unusable. Value should be a function, accepting user as the only parameter and returning its secret key as string.  Default is  None .  JWT_PRIVATE_KEY  Can be a scalar or a dict.  When a dict, the dict key is taken as the JWT key id and the values as\nthe key, e.g.:  { \"kid\": key }  The scalar or the dict value must be in any  private key format supported by PyJWT , for example of the types   cryptography.hazmat.primitives.asymmetric.rsa.RSAPrivateKey  cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePrivateKey   And will be used to sign the signature component of the JWT if  JWT_ALGORITHM  is set to any of the  supported algorithms   other than the hash types  HS* .  Default is  None .  JWT_PUBLIC_KEY  Can be a scalar, a list or a dict.   When a dict, the dict keys are taken as the JWT key ids and the values as\n  keys, e.g.:   python\n  { \"kid1\": key1, \"kid2\": key2, ... }  If a JWT that contains a key id (kid header) is to be verified, only\n  the associated key is tried. Otherwise, or   when a list, all of the elements will be accepted for verification of JWTs with  alg  being (any of)  JWT_ALGORITHM  not matching  HS* .   The scalar or elements/values of the list/dict must be in any  public key format supported by PyJWT , for example of the types   cryptography.hazmat.primitives.asymmetric.rsa.RSAPublicKey  cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePublicKey   Default is  None .  JWT_ALGORITHM  Possible values are any of the  supported algorithms  for cryptographic signing in  PyJWT .  Can be a scalar or a list.    For a scalar, this algorithm is used for signing and verification.    For a list, the first element is used for signing and all elements are accepted for verification.    Default is  \"HS256\" .  JWT_INSIST_ON_KID  When key IDs are used ( JWT_SECRET_KEY  and/or  JWT_PUBLIC_KEY  given\nas a dict assigning key IDs to keys), insist that JWTs to be validated\nhave a  kid  header with a defined key.  Default is  False .  JWT_TOKEN_ID  Configure whether tokens have a  jti  token id claim (and refreshed tokens have a  orig_jti  claim).  May be set to:   off : do not include token id claims in tokens  include : add token id claims to tokens, but continue accepting old tokens without them  require : add token id claims to tokens, and reject tokens that lack them   The default has been to include these claims since version 1.17.  For new installations, please override the default and set this to  require , as every token will have an id from the outset.  For existing installations, when migrating from an older version (pre-1.17) or when changing the setting from  off , we recommend setting this to  require  once all of the valid tokens have the id claims. This will typically be after  JWT_EXPIRATION_DELTA  has elapsed since upgrading or allowing id claims to be included.  Note that when set to  off  or  include , the blacklist functionality - if used - will store the entire token value, which would allow someone with access to the administrative interface, or directly to the database, to steal an otherwise valid token and remove it from the blacklist. Using  require  for this setting means that only token identifiers are recorded for the blacklist and not entire tokens.  Default is  include .  JWT_AUDIENCE  This is a string that will be checked against the  aud  field of the token, if present.  Default is  None  (fail if  aud  present on JWT).  JWT_ISSUER  This is a string that will be checked against the  iss  field of the token.  Default is  None  (do not check  iss  on JWT).  JWT_ENCODE_HANDLER  Encodes JWT payload data and returns JWT token.  JWT_DECODE_HANDLER  Decodes JWT token and returns JWT payload data.  JWT_PAYLOAD_HANDLER  Specify a custom function to generate the token payload  JWT_PAYLOAD_GET_USERNAME_HANDLER  If you store  username  differently than the default payload handler does, implement this function to fetch  username  from the payload.  JWT_PAYLOAD_INCLUDE_USER_ID  If you do not wish to include the user's primary key (typically  id ) in the token payload, then set this to  False .  Default is  True .  JWT_VERIFY  If the secret is wrong, it will raise a  jwt.DecodeError . You can still get the payload by setting the  JWT_VERIFY  to  False .  Default is  True .  JWT_VERIFY_EXPIRATION  You can turn off expiration time verification by setting  JWT_VERIFY_EXPIRATION  to  False .\nWithout expiration verification, JWTs will last forever meaning a leaked token could be used by an attacker indefinitely.  Default is  True .  JWT_LEEWAY  This allows you to validate an expiration time which is in the past but not very far. For example, if you have a JWT payload with an expiration time set to 30 seconds after creation but you know that sometimes you will process it after 30 seconds, you can set a leeway of 10 seconds in order to have some margin.  Default is  0  seconds.  JWT_EXPIRATION_DELTA  This is an instance of Python's  datetime.timedelta . This will be added to  datetime.utcnow()  to set the expiration time.  Default is  datetime.timedelta(seconds=300)  (5 minutes).  JWT_ALLOW_REFRESH  Enable token refresh functionality. Token issued from  rest_framework_jwt.views.obtain_jwt_token  will have an  orig_iat  field.  Default is  True .  JWT_REFRESH_EXPIRATION_DELTA  Limit on token refresh, is a  datetime.timedelta  instance. This is how much time after the original token that future tokens can be refreshed from.  Default is  datetime.timedelta(days=7)  (7 days).  JWT_AUTH_HEADER_PREFIX  You can modify the Authorization header value prefix that is required to be sent together with the token.  Default value is  Bearer .  JWT_RESPONSE_PAYLOAD_HANDLER  Creates a response payload instance that will get passed to authentication response serializer.\nYou might want to implement your own handler if you use custom response serializer (typical use-case would be including serialized  user  object in response).  By default returns a  namedtuple  with attributes  pk  (issued-at time) and  token .  Example:  def jwt_create_response_payload(token, user=None, request=None, issued_at=None):\n    \"\"\"\n    Return data ready to be passed to serializer.\n\n    Override this function if you need to include any additional data for\n    serializer.\n\n    Note that we are using `pk` field here - this is for forward compatibility\n    with drf add-ons that might require `pk` field in order (eg. jsonapi).\n    \"\"\"\n\n    response_payload = namedtuple('ResponsePayload', 'pk token user')\n    response_payload.pk = issued_at\n    response_payload.token = token\n    response_payload.user = user\n\n    return response_payload  JWT_AUTH_COOKIE  You can set this to a string if you want to use http cookies in addition to the Authorization header as a valid transport for the token.\nThe string you set here will be used as the cookie name that will be set in the response headers when requesting a token. The token validation\nprocedure will also look into this cookie, if set. The 'Authorization' header takes precedence if both the header and the cookie are present in the request.  Default is  None  and no cookie is set when creating tokens nor accepted when validating them.  JWT_AUTH_COOKIE_DOMAIN  Default:  None  The domain to use for the JWT cookie analogous to SESSION_COOKIE_DOMAIN  for django sessions.  Has no effect unless JWT_AUTH_COOKIE is set.  JWT_AUTH_COOKIE_PATH  Default:  /  The path to set on the JWT cookie analogous to  SESSION_COOKIE_PATH \nfor django sessions.  Has no effect unless JWT_AUTH_COOKIE is set.  JWT_AUTH_COOKIE_SECURE  Default:  True  Whether to use a secure cookie for the JWT cookie analogous to SESSION_COOKIE_SECURE  for django sessions.  Users wishing to use JWT cookies over http (as in no TLS/SSL) need to\nset  JWT_AUTH_COOKIE_SECURE  to  False.  Has no effect unless JWT_AUTH_COOKIE is set.  JWT_AUTH_COOKIE_SAMESITE  Default:  Lax  The value of the  SameSite  flag on the the JWT cookie analogous to SESSION_COOKIE_SAMESITE  for django sessions.  Has no effect unless JWT_AUTH_COOKIE is set.  Has no effect with Django versions before 2.1.  JWT_IMPERSONATION_COOKIE  Analogous to the  JWT_AUTH_COOKIE  setting, but contains the impersonation token, i.e. the token of the user who is being impersonated.  This cookie takes precedence over the  JWT_AUTH_COOKIE . If you have both cookies and you want to end the impersonation, you have to remove the cookie.   Impersonation cookies use the  JWT_AUTH_COOKIE_*  settings.  JWT_DELETE_STALE_BLACKLISTED_TOKENS  Enables deleting of stale blacklisted tokens on  post_save  when set to  True . All blacklisted\n tokens that have expired will be deleted.  Default is  False .",
            "title": "Additional Settings"
        },
        {
            "location": "/#extendingoverriding-jsonwebtokenauthentication",
            "text": "Right now  JSONWebTokenAuthentication  assumes that the JWT will come in the header, or a cookie if configured (see  JWT_AUTH_COOKIE ). The JWT spec does not require this (see:  Making a service Call ). For example, the JWT may come in the querystring. The ability to send the JWT in the querystring is needed in cases where the user cannot set the header (for example the src element in HTML).  To achieve this functionality, the user might write a custom  Authentication  class:  class JSONWebTokenAuthenticationQS(JSONWebTokenAuthentication):\n\n    def get_jwt_value(self, request):\n        return request.QUERY_PARAMS.get('jwt')",
            "title": "Extending/Overriding JSONWebTokenAuthentication"
        },
        {
            "location": "/#creating-a-new-token-manually",
            "text": "Sometimes you may want to manually generate a token, for example to return a token to the user immediately after account creation. You can do this as follows:  from rest_framework_jwt.settings import api_settings\n\njwt_payload_handler = api_settings.JWT_PAYLOAD_HANDLER\njwt_encode_handler = api_settings.JWT_ENCODE_HANDLER\n\npayload = jwt_payload_handler(user)\ntoken = jwt_encode_handler(payload)",
            "title": "Creating a new token manually"
        },
        {
            "location": "/#creating-a-new-token-on-the-command-line",
            "text": "There is a management command which you can use to obtain a JWT token, for example:  python manage.py obtain_token username=John\n# or\npython manage.py obtain_token pk=1  it could be easier during development, to run this management command instead of using login API.",
            "title": "Creating a new token on the command line"
        }
    ]
}